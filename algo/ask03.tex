% -*- mode: LaTeX; coding: utf-8 -*-
% Typeset with: XeLaTeX

\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}
\usepackage{amsmath}

% Greek fonts
\RequirePackage[cm-default]{fontspec}
\defaultfontfeatures{Mapping=tex-text}
  % you may want to try: {FreeSerif} or {Times New Roman}
\setmainfont{Liberation Serif}
  % you may want to try: {FreeSans} or {Arial}
\setsansfont[Scale=MatchLowercase]{Liberation Sans}
  % you may want to try: {FreeMono} or {Courier New}
\setmonofont[Scale=MatchLowercase]{Liberation Mono}
\setlength{\parskip}{1em}

\newcommand\nlambda[1]{\ensuremath{\lambda #1.\,}}
\newcommand\nred{\ensuremath{\longrightarrow}}

% Main document
\begin{document}
\title{Αλγόριθμοι και Πολυπλοκότητα - 3η Σειρά Ασκήσεων}
\author{Θωμάς Παππάς}
\date{22 Ιανουαρίου 2020}
\maketitle
\begin{center}ΑΜ: AL1180011\end{center}

\section*{Ασκηση 1: Ο Άγιος Βασίλης και τα Χρυσά Κλειδιά}

Για αρχή παρατηρούμε ότι οι σχέσεις μεταξύ των κουτιών και τα κουτιά τα οποία ανοίγουν τα κλειδιά που έχουν μέσα τους, μπορεί να αναπαραστεί σε έναν κατευθυνόμενο γράφο $G$ όπου ένας κόμβος θα αναπαραστά ένα κουτί και μια ακμή $(u, v)$ θα σημαίνει ότι το κουτί $u$ περιέχει ένα κλειδί που ξεκλειδώνει το κουτί $v$.

Ξεκινώντας λοιπόν θα διαβάσουμε το input χρόνο και σε $\mathcal{O}(m)$ χρόνο θα κατασκευάσουμε το γράφο $G$ σε έναν πίνακα γειτνίασης μεγέθους $n \times n$, καθώς και τον ανάστροφό του $G^T$ (ο ανάστροφος πίνακα γειτνίασης του $G$). Επίσης θα δημιουργήσουμε δύο queues ακαιρέων \verb|boxToCrack| \verb|boxUnlockOrder| για να αποθηκεύσουμε τα κουτιά που θα σπάσουμε και τη σειρά με την οποία θα ξεκλειδώσουμε τα κουτιά αντίστοιχα.

Τώρα θα προχωρήσουμε με τα εξής βήματα:
\begin{itemize}
  \item Διαχείρηση Τετριμένων περιπτώσεων (όπου το κουτί δεν μπορεί να ξεκλειδωθεί)
  \item Εύρεση Ισχυρά Συνεκτικών Συνιστωσών (ΙΣΣ) και κατασκευή DAG γράφου $G_{DAG}$
  \item DFS στο $G_{DAG}$ και κατασκευή $max$ κουτιών που μπορεί να ξεκλειδώσει το κάθε κουτί
\end{itemize}

\subsection*{Τετριμένες περιπτώσεις}
Προφανώς αν ένας κόμβος-κουτι $u$ με εισερχόμενο βαθμό $deg(u) = 0$ ή $1$ με μοναδική ακμή την $(u, u)$ είναι κουτιά που δεν μπορούν να ξεκλειδωθούμε με κάποιο από τα κλειδιά και άρα θα πρέπει να τα σπάσουμε.

Κατά τη διάρκεια που διαβάζουμε το input μπορούμε να κρατήσουμε αυτούς τους κόμβους σε ένα stack/queue, έτσι ώστε μετά να κάνουμε DFS στον καθένα τους. Δηλαδή για κάθε κόμβο $u$ με την παραπάνω ιδιότητα κάνουμε \verb|boxCrack.push(u)| και μετά κάνοντας ΒFS στο $u$ τοποθετούμε κάθε κόμβο που επισκεπτόμαστε σε σειρά χρόνων αφίξεως στο \verb|boxUnlockOrder|.

Τους κόμβους που επισκεφθήκαμε μπορούμε να τους βγάλουμε από το γράφο $G$. Σπάσαμε τα κουτιά που δεν είχαμε άλλη επιλογή, ανοίξαμε όσα κουτιά μας επέτρεψαν αυτά, και άρα οποιαδήποτε άλλη σύνδεση με τα υπόλοιπα κουτιά είναι αδιάφορη.

\subsection*{ΙΣΣ και DAG}
Ο γράφος $G$ ενδεχομένως να αποτελείται από υπογράφους ξένους μεταξύ τους. Για τα παρακάτω βήματα, θα πάρουμε έναν τυχαίο κόμβο (τον επόμενο που δεν έχουμε επισκεφθεί),θα δουλέψουμε πάνω στους κόμβους με τους οποίους συνδέεται, και μετά θα επαναλάβουμε τα βήματα μέχρι να έχουμε επισκεφθεί όλους τους κόμβους.

Χρησιμοποιύμε τον αλγόριθμο Kosaraju στον $G$. Πρώτα φτιάχνουμε μια λίστα από λίστες ακαιρέων \verb|sccs| για να κρατήσουμε τα σύνολα των ΙΣΣ που θα συναντήσουμε. Παίρνουμε λοιπόν έναν τυχαίο αρχικό κόμβο $u$ και κάνουμε DFS κρατώντας τους χρόνους αναχώρησης $f(u)$ σε κάθε βήμα, ώστε εντέλει να πάρουμε την Τοπολογική Διάταξη των κόμβων. Κρατάμε λοιπόν σε ένα stack \verb|topologicalOrder| τους κόμβους που περνάμε με τη σειρά των χρόνων αναχώρησης.

Σε αυτό το σημείο μπορούμε να πούμε ότι τα παραπάνω DFS μαζί με όσα ΒFS κάναμε στις τετριμμένες περιπτώσεις, έχουμε χρησιμοποιήσει συνολικά χρόνο $\mathcal{O}(m+n)$.

Τώρα χρησιμοποιώντας τον πίνακα $G^T$, κάνουμε σε χρόνο $\mathcal{O}(m+n)$ DFS στους κόμβους με τη σειρά της Τοπολογικής Διάταξης (παίρνοντας δηλαδή τα στοιχεία από το stack \verb|topologicalOrder|). Κάθε φορά που το DFS τελειώνει τότε αποθηκεύουμε τα στοιχεία που επισκεφθήκαμε σε μια λίστα μέσα στον \verb|sccs|, αφού αυτά τα στοιχεία αποτελούν μια ΙΣΣ του $G^T$ (και άρα και του $G$).

Μετά διαβάζουμε τη λίστα \verb|scc| και φτιάχνουμε ένα γράφο $G_{DAG}$ όπου κάθε κόμβος αντιστοιχεί σε ένα στοιχείο του \verb|sccs| και κατασκευάζουμε τις ακμές διαβάζοντας σε χρόνο $matcal{0}(m)$ τις ακμές του $G$ από τη μια ΙΣΣ στην άλλη. Δηλαδή
\begin{verbatim}
for scc in sccs:
  dag_node = GT.addOrGet(scc)
  for box in scc:
    for (edges from box as edge):
      if edge.to not in scc:
        scc' = find(edge.to in sccs[])
        dag_node' = GT.addOrGetNode(scc')
        GT.createEdge(dag_node, dag_node')
        break      
\end{verbatim}

\subsection*{Μέτρηση max κουτιών στον DAG}
Κάνουμε σε χρόνο $\mathcal{O}(m+n)$ ένα DFS πάνω στον $G^T$ και με τη σειρά των χρόνων αναχώρησης κατασκευάζουμε μια λίστα ακεραίων \verb|maxBoxesToUnlock| όπου θα κρατήσουμε το πόσα κουτιά μπορεί να ξεκλειδώσει ο κάθε κόμβος-κουτί. Εδώ παρατηρούμε ότι αυτό δουλεύει διότι για κάθε κόμβο $u$ και $v$ με $u, v$ στην ίδια ΙΣΣ θα ισχύει \verb|maxBoxesToUnlock[u] = maxBoxesToUnlock[v]|, και άρα μπορούμε να κρατήσουμε μόνο μια φορά αυτόν τον αριθμό, με τον καθένα να αντιστοιχεί στον αντίστοιχο κόμβο του $G^T$ που αντιπροσωπεύει την αντίστοιχη ΙΣΣ. Ο αριθμός αυτός θα είναι όσο το πλήθος των στοιχείων της ΙΣΣ + το αθροισμα των \verb|maxBoxesToUnlock[u]| αριθμών των απογόνων του.

Κρατάμε το $max$ και κάνοντας BFS ξεκινώντας από έναν τυχαίο αντιπρόσωπο της αντίστοιχης ΙΣΣ κάνουμε \verb|boxCrack.push(u)| για την πρώτη περίπτωση και \verb|boxUnlockOrder.push(u)| για κάθε κόμβο $u$ που επισκεπτόμαστε στη συνέχεια. Συνεχίζουμε μέχρι να σπάσουμε/επισκεφθούμε όλους τους κόμβους.

Η απάντηση στο πρόβλημα είναι η ουρες \verb|boxCrack.push(u)| και \verb|boxUnlockOrder| και ο συνολικός χρόνος που θα χρειαστεί είναι $\mathcal{O}(m+n)$.

\section*{Άσκηση 2: Μακρύτερο Μονοπάτι σε Δέντρο}
Εδώ εφόσον πρόκειται για δέντρο, η πολυπλοκότητα οποιοδήποτε BFS/DFS πραγματοποιήσουμε θα μας πάρει $\Theta(n+(n-1)) = \Theta(n)$.

Δημιουργούμε λοιπόν έναν ακέραιο \verb|maxWeight| και μια λίστα \verb|path| για να αποθηκεύσουμε τα ζητούμενα. Παρατηρούμε τώρα ότι αρκεί να υπολογίσουμε τα μονοπάτια που ξεκινάνε από έναν κόμβο προς τους απογόνους του, διότι εάν υπάρχει ένα μονοπάτι μέγιστου συνολικού βάρους με το κόμβο και τον γονέα του, τότε αυτό το νούμερο θα εμφανιστεί όταν το υπολογίσου για το δικό του υποδέντρο (του γονέα). Άρα το μόνο που μένει να δούμε αν ο κόμβος συμμετέχει στην optimal λύση ως άκρη (και άρα υπολογίζουμε την τιμή του από το $max$ των αντίστοιχων τιμών στα παιδιά του) ή ως μέσο (και άρα υπολογίζουμε την τιμή του από το $max$ άθροισμα δύο -διαφορετικών- παιδιών του).

Πραγματοποιούμε λοιπόν DFS στο δέντρο ξεκινώντας από τη ρίζα και κρατώντας δύο στοιχεία για κάθε κόμβο $u$ που εξερευνούμε, το $max$ βάρος $w_e(u)$ που έχει ο κόμβος ως η άκρη ενός μονοπατιού και το $max$ βάρος $w_m(u)$ που έχει ο κόμβος όταν ΔΕΝ είναι η άκρη ενός μονοπατιού. Έτσι, εφόσον μέσω του DFS εξερευνούμε (και άρα ξεκινάμε να υπολογίσουμε) είτε φύλλα είτε κόμβους που έχουμε ήδη υπολογίζει τα αντίστοιχα βάρη όλων των παιδιών του \verb|children(u)|, ο υπολογισμός γίνεται ως εξής:
$$w_e(u) =
  \begin{cases}
    0, & \text{$w(u) \leq 0$}\\
    w(u) + max\{w_e(v) | v \in \verb|children(u)|\}, & \text{διαφορετικά}
  \end{cases}$$
$$w_m(u) = w(u) + max\{w_e(v_1) + w_e(v_2)| v_1 \neq v_2, v_1, v_2 \in \verb|children(u)|\}$$
Επίσης ενώ τρέχουμε τους από πάνω υπολογισμούς, κρατάμε και τους κόμβους $v, v_1, v_2$ που επιλέξαμε για κάθε κόμβο $u$ (πχ. σε μια λίστα με 3-άδες $(v, v_1, v_2)$) έτσι ωστε μετά να μπορέσουμε να ανατρέξουμε στο μονοπάτι που θέλουμε.

Για τις περιπτώσεις που ο κόμβος έχει μη θετικό βάρος τότε ξέρουμε ότι δεν πρόκειται να ανήκει ως άκρη σε μονοπάτι μέγιστου συνολικού βάρους αφού το μονοπάτι χωρίς αυτόν τον κόμβο θα έχει σίγουρα μεγαλύτερο ή ίσο συνολικό βάρος.

Ενώ τρέχουμε τους παραπάνω υπολογισμούς συγκρίνουμε τα $w_e, w_m$ και κρατάμε το μεγαλύτερο στο \verb|maxWeight|. Στο τέλος η τιμή του \verb|maxWeight| καθώς και το μονοπάτι που έχει αυτήν την τιμή (το οποίο αποθηκεύουμε στο \verb|path| μέσω των 3-άδων που ορίσαμε παραπάνω).

Για να υπολογίσουμε την πολυπλοκότητα του αλγορίθμου, αρκεί να παρατηρήσουμε ότι ενώ τρέχει το DFS τότε ο κάθε κόμβος θα υπολογιστεί μια φορά και θα συγκριθεί από μια φορά (όταν φτάσει η στιγμή να υπολογιστεί ο γονέας του). Οπότε ο συνολικός χρόνος εκτέλεσης θα παραμείνει $\Theta(n)$.

\section*{Άσκηση 3: Κλέφτες και Αστυνόμοι}

Πρώτον παρατηρούμε ότι μπορούμε να αναπαραστήσουμε τις πιθανές κινήσεις του Κώστα και του Ανδρέα σε έναν γράφο $G_{game}(V \times V \times \{K, A\}, E')$ όπου κάθε κορυφή θα αναπαριστά μια κατάσταση του παιχνιδιού, ενώ οι ακμές τις πιθανές κινήσεις από τη μια στην άλλη. Ο κάθε κόμβος θα συνδέεται με μια 3-άδα $(u, v, P)$ όπου το $u$ είναι η κορυφή που βρίσκεται ο Κώστας, $v$ η κορυφή που βρίσκεται ο Αντρέας και το $P$ τον παίκτη Α ή Κ που είναι η σειρά του να παίξει. Συνεπώς για κάθε ακμή $(u, v)$ του $G$ έχουμε ότι $\forall w \in V$ οι $((u, w, K), (v, w, A))$ και $((w, u, A), (w, v, K))$ είναι ακμή του $G_{game}$.

Προφανώς αποκλείουμε τους κόμβους όπου ο Αλέξης βρίσκεται στην κορυφή-καταφύγιο. Θα μαρκάρουμε τώρα τον κάθε κόμβο στο $G_{game}$ με το αν από αυτήν την κατάσταση θα νικήσει σίγουρα ο Κώστας ή ο Αντρέας. Προφανώς για κάθε κόμβο $(u, v, P)$ όπου $u$ το καταφύγιο τότε νικάει ο Κώστας, ενώ για κάθε $(u, u, P)$ νικάει ο Αντρέας. Τώρα αν ο Κώστας έχει κάποια κατάσταση γύρω του που νικάει τότε νικάει και σε αυτή που βρίσκεται, ενώ αν παντού νικάει ο Αντρέας τότε νικάει και εκεί που είναι. Αντίστροφα για τον Αντρέα.

Πραγματοποιούμε μια τοπολογική κατανομή στις ακμές (ώστε να σιγουρευτούμε ότι το καταφύγιο θα είναι τελευταίο) και πραγματοποιούμε ένα DFS και υπολογίζουμε τις βέλτιστες κινήσεις από κάθε κατάσταση.

Ο χρόνος εκτέλεσης αποτελείται από την κατασκευή του $n \times n \times 2$ γράφου $G_{game}$ καθώς και από το DFS που πραγματοποιήθηκε σε αυτόν. Συνεπώς συνολικά έχουμε πολυπλοκότητα $\mathcal{O}(n^2) + \mathcal{O}(n^2) = \mathcal{O}(n^2)$.

\end{document}
