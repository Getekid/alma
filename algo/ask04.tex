% -*- mode: LaTeX; coding: utf-8 -*-
% Typeset with: XeLaTeX

\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}
\usepackage{amsmath}

% Greek fonts
\RequirePackage[cm-default]{fontspec}
\defaultfontfeatures{Mapping=tex-text}
  % you may want to try: {FreeSerif} or {Times New Roman}
\setmainfont{Liberation Serif}
  % you may want to try: {FreeSans} or {Arial}
\setsansfont[Scale=MatchLowercase]{Liberation Sans}
  % you may want to try: {FreeMono} or {Courier New}
\setmonofont[Scale=MatchLowercase]{Liberation Mono}
\setlength{\parskip}{1em}

\newcommand\nlambda[1]{\ensuremath{\lambda #1.\,}}
\newcommand\nred{\ensuremath{\longrightarrow}}

% Main document
\begin{document}
\title{Αλγόριθμοι και Πολυπλοκότητα - 4η Σειρά Ασκήσεων}
\author{Θωμάς Παππάς}
\date{16 Φεβρουαρίου 2020}
\maketitle
\begin{center}ΑΜ: AL1180011\end{center}

\section*{Ασκηση 1: Επιβεβαίωση και Αναπροσαρμογή Συντομότερων Μονοπατιών}

\subsection*{(α)}
Δεδομένου ότι έχουμε έναν (ενδεχομένως λάθος) ισχυρισμό για όλα τα συντομότερα μονοπάτια από μια κορυφή $u_1$, μπορούμε να χρησιμοποιήσουμε αυτήν την πληροφορία για να υπολογίσουμε το Δέντρο Συντομότερων Μονοπατιών από το $u_1$ σε γραμμικό χρόνο.

Αν ο ισχυρισμός είναι λάθος, τότε θα υπάρχει ένα μονοπάτι $(u_1, u_i)$ τέτοιο ώστε $d(u_1, u_i) \neq \delta_i$, και προχωρώντας επαγωγικά στις κορυφές αυτού του μονοπατιού μπορούμε να βρούμε το μικρότερο $j$ για το οποίο $d(u_1, u_j) \neq \delta_j$. Παρατηρούμε ότι εφόσον μας αρκεί ένα λάθος για να ξέρουμε ότι ο αρχικός ισχυρισμός είναι εσφαλμένος, τότε αρκεί να ελέγξουμε μόνο την τελευταία ακμή ενός μονοπατιού, με το δεδομένο ότι η απόσταση του γονέα του με το $u_1$ είναι η ισχυριζόμενη. Τέλος μένει να κρατήσουμε σε έναν πίνακα ποιες κορυφές έχουν επιβεβαιωμένες τις αποστάσεις τους, ώστε στο τέλος θα μπορούμε να αποφανθούμε αν είναι όλες σωστές.

Ξεκινώντας λοιπόν φτιάχνουμε μια integer λίστα \verb|parents[]| $n$ μεγέθους όπου θα κρατάμε τους γονείς των κορυφών που έχουν επιβεβαιώσει την απόστασή τους $d(u_1, u_i) = \delta_i$. Αρχικοποιούμε τη λίστα βάζοντας παντού $-1$.

Από την κορυφή $u_1$ Θα τρέξουμε BFS (σε χρόνο $\mathcal{O}(|G|+|V|)$) και σε κάθε αναδρομή μιας κορυφής $u_p$ θα συγκρίνουμε για κάθε παιδί $u_c$ τις τιμές $\delta_c$ και $\delta_p + w(u_p,u_c)$ ως εξής:
\begin{itemize}
  \item Αν $\delta_c > \delta_p + w(u_p,u_c)$, τότε έχουμε βρει συντομότερο μονοπάτι από το ισχυριζόμενο, άρα τερμάτισε και επέστρεψε \verb|false|
  \item Αν $\delta_c = \delta_p + w(u_p,u_c)$, τότε σημειώνουμε \verb|parents[c] = p| και συνεχίζουμε
  \item Αν $\delta_c < \delta_p + w(u_p,u_c)$, τότε δεν κάνουμε τίποτα και συνεχίζουμε
\end{itemize}
Στο τέλος ελέγχουμε αν για τη λίστα \verb|parents| υπάρχει κάποιο στοιχείο $k$ τέτοιο ώστε \verb|parents[k] = -1|. Αν υπάρχει, τότε τερματίζουμε και επιστρέφουμε \verb|false|. Αν όχι τότε σημαίνει ότι όλες οι αποστάσεις $\delta_1, ..., \delta_n$ έχουν επιβεβαιωθεί ως σωστές και άρα επιστρέφουμε τον πίνακα \verb|parents| ο οποίος αποτελεί την περιγραφή του ΔΣΜ με ρίζα την κορυφή $u_1$.

Τα operations που τρέχουμε σε κάθε αναδρομή του BFS είναι χρόνου $\Theta(1)$ ενώ ο τελευταίος έλεγχος της λίστας \verb|parents| θα πάρει το πολύ $\mathcal{O}(n)$. Άρα συνολικά ο χρόνος που απαιτείται για τον παραπάνω αλγόριθμο είναι $\mathcal{O}(|G|+|E|)$.

\subsection*{(β)}
Παρατηρούμε ότι για να αναπροσαρμόσουμε τις ελάχιστες αποστάσεις μεταξύ όλων των κορυφών σε νέες τιμές $d^\prime(u_i,u_j)$, αρκεί να ελέγξουμε τα μονοπάτια στα οποία συμμετέχει η ακμή $e$. Αν η ακμη $e = (x,y)$ συμμετέχει σε ένα τέτοιο μονοπάτι (και εφόσον δεν έχουμε κύκλους αρνητικού μήκους) τότε αυτό θα έχει απόσταση
$$d_e^\prime(u_i,u_j) = d(u_i,x) + w^\prime(x,y) + d(y,u_j)$$

Επίσης από την τριγωνική ανισότητα ξέρουμε ότι για κάθε (καινούργιο) συντομότερο μονοπάτι ισχύει ότι
$$d(u_i,u_j) \leq d(u_i,x) + w(x,y) + d(y,u_j)$$
ενώ επίσης
$$d^\prime(u_i,u_j) \leq d(u_i,x) + w^\prime(x,y) + d(y,u_j)$$
με τις ισότητες να ισχύουν όταν η ακμή $e$ είναι μέρος του συντομότερου μονοπατιού. Προφανώς ισχύει ότι $d^\prime(u_i,u_j) \leq d(u_i,u_j)$.

Διακρίνουμε λοιπόν τις εξής περιπτώσεις:
\begin{itemize}
  \item Αν $d(u_i,u_j) < d_e^\prime(u_i,u_j)$ τότε το αρχικό συντομότερο μονοπάτι δεν χρησιμοποιούσε την ακμή $e$ και εφόσον παραμένει μικρότερο τότε παίρνουμε $d^\prime(u_i,u_j) = d(u_i,u_j)$
  \item Αν $d(u_i,u_j) \geq d_e^\prime(u_i,u_j)$ τότε το μονοπάτι με την ακμή $e$ έχει συντομότερη ή ίση απόσταση από πριν, και άρα παίρνουμε $d^\prime(u_i,u_j) = d_e^\prime(u_i,u_j)$
\end{itemize}
  
Οι πράξεις που κάνουμε για κάθε ζευγάρι απαιτούν χρόνο $\Theta(1)$ και εφόσον ελέγχουμε για κάθε κορυφή σε κάθε άλλη κορυφή, άρα ο συνολικός απαιτούμενος χρόνος είναι $\mathcal{O}(n^2)$.

\subsection*{(γ)}
Αν το μήκος μιας ακμής $e = (x,y)$ αυξηθεί σε $w^\prime(x,y) > w(x,y)$ τότε ΔΕΝ μπορούμε να επεκτείνουμε τον αλγόριθμο του (β) για να βρούμε τις νέες αποστάσεις. Ο λόγος είναι ότι δεν έχουμε κάποιο κάτω φράγμα για το $d^\prime(u_i,u_j)$ (όπως είχαμε πριν άνω φράγμα με την τριγωνική ανισότητα).

Πιο συγκεκριμένα, εφόσον η ακμή $e$ αυξήθηκε, τότε έχουμε πάντα
$d(u_i,u_j) < d_e^\prime(u_i,u_j)$ χωρίς να ξέρουμε σε ποια περίπτωση του αλγορίθμου βρισκόμαστε. Ακόμα και αν ξέραμε ότι η ακμή $e$ συμμετείχε στο μονοπάτι με $d(u_i,u_j)$ και πάλι δεν μπορούμε να γνωρίζουμε αν με την επαυξημένη ακμή θα υπάρχει άλλο μονοπάτι με $d(u_i,u_j) < d^\prime(u_i,u_j) < d_e^\prime(u_i,u_j)$, και άρα ο αλγόριθμος δεν μπορεί να δουλέψει.

\end{document}
