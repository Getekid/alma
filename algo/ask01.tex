% -*- mode: LaTeX; coding: utf-8 -*-
% Typeset with: XeLaTeX

\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}

% Greek fonts
\RequirePackage[cm-default]{fontspec}
\defaultfontfeatures{Mapping=tex-text}
  % you may want to try: {FreeSerif} or {Times New Roman}
\setmainfont{Liberation Serif}
  % you may want to try: {FreeSans} or {Arial}
\setsansfont[Scale=MatchLowercase]{Liberation Sans}
  % you may want to try: {FreeMono} or {Courier New}
\setmonofont[Scale=MatchLowercase]{Liberation Mono}
\setlength{\parskip}{1em}

\newcommand\nlambda[1]{\ensuremath{\lambda #1.\,}}
\newcommand\nred{\ensuremath{\longrightarrow}}

% Main document
\begin{document}
\title{Αλγόριθμοι - 1η Σειρά Ασκήσεων}
\author{Θωμάς Παππάς}
\date{12 Νοεμβρίου 2019}
\maketitle
\begin{center}ΑΜ: AL1180011\end{center}

\section*{Ασκηση 1}
(α) Η σειρά κατάταξης είναι:
\begin{center}
\begin{tabular}{ c c c c }
$\sum_{k=1}^nk2^{-k}$ & $\log{(n!)}/(\log{n})^3$ & $n2^{2^{2^{100}}}$ & $\log{2n\choose n}$ \\
$2^{(\log_2n)^4}$ & $(\sqrt{n})!$ & $n\sum_{k=0}^n{n\choose k}$ & $\sum_{k=1}^nk2^k$ \\
\end{tabular}
\end{center}
όπου $n\sum_{k=0}^n{n\choose k} = \sum_{k=1}^nk2^k = \Theta(n2^n)$, αφού $n\sum_{k=0}^n{n\choose k} = n\sum_{k=1}^n(1+1)^n = n2^n$

%\section*{Άσκηση 2}
%
%(α) Ο ακόλουθος αλγόριθμος υπολογίζει την ελάχιστην τιμή της παράστασης $|A_1[i_1]-A_2[i_2]|$.
%
%\begin{verbatim}
%function getMinDist(array a1, array a2):
%  if a1[0] > a2[0]:
%    inverseResult = getMinDist(a2, a1);
%    return (inverseResult[1], inverseResult[0]);
%
%  int i = 0;
%  int j = 0;
%  while a1[i] =< a2[j]:
%    if (a1[i] == a2[j]:
%      return (i,j);
%    j++;
%\end{verbatim}
%
%Ο αλγόριθμος \verb|getMinDist| χρεάζεται

\section*{Άσκηση 3}
1. Ο αλγόριθμος \verb|minifyStacks| που ελαχιστοποιεί το πλήθος των στοιβών που δημιουργούνται κατά τη διάρκεια του παιχνιδιού είναι ο εξής:\\
Πρώτα θα κρατήσουμε τις κορυφές της κάθε στοίβας σε ένα δυαδικό δέντρο \verb|topCardTree|. Κάθε φορά που θα τραβάμε μια κάρτα \verb|card| κάνουμε δυαδική αναζήτηση στο δέντρο και βρίσκουμε θέση \verb|i| τέτοια ώστε \verb|topCardTree[i] < card < topCardTree[i+1]|. Αντικαθιστούμε το \verb|topCardTree[i+1]| με την τιμή \verb|card|. Εάν το στοιχείο δεν υπάρχει στο δέντρο (δηλαδή η κάρτα έχει μεγαλύτερη τιμή από κάθε στήλη) τότε δημιουργούμε μια νέα στοίβα και προσθέτουμε ένα κλαδί στο \verb|topCardTree|.

\begin{verbatim}
function minifyStacks(stack deck):
  stacks = new stack[]
  topCardTree = new BinaryTree()

  index = 0
  while deck.length > 0:
    card = deck[index].pop()
    i = topCardTree.binarySearch(card).getLowerIndex()
    if topCardTree[i+1]:
      stacks[i].push(card)
      topCardTree[i+1] = card
    else:
      stacks.append(new stack({}))
      topCardTree.add(card)
\end{verbatim}

Η ιδέα του αλγορίθμου είναι ότι τοποθετούμε την κάρτα στη στοίβα με τη μικρότερη δυνατή τιμή και εάν δεν υπάρχει δυνατή στοίβα προφανώς δημιούργούμε καινούργια στοίβα. Ο αλγόριθμος είναι ορθός διότι οποιαδήποτε άλλη κίνηση θα δημιουργήσει ενδεχόμενα να δημιούργηθούν επιπλέον στοίβες. Εάν επιλέξουμε να βάλουμε μια κάρτα \verb|card| στη στοίβα \verb|stack1| ενώ υπάρχει επίσης δυνατή στοίβα \verb|stack2 > stack1|, τότε μια κάρτα \verb|stack1 < card < stack2| θα αναγκαστούμε να την βάλουμε σε καινούργια στοίβα. Το να καρατάμε τις κορυφές ταξινομημένες δεν είναι απαραίτητο πχ. αν έχουμε στην κορυφή κάρτες \verb|3| και \verb|4|, το \verb|2| θα μπορούσαμε να το βάλουμε σε οποιαδήποτε από τις δύο στοίβες χωρίς να επηρεάσουμε το πλήθος των στοιβών που δημιουργούνται. Απλά κρατώντας τις κορυφές ταξινομιμένες, καταφέρνουμε να εκτελέσουμε πιο γρήγορα την αναζήτηση (ή δημιουργία) της στοίβας που θα τοποθετήσουμε την κάρτα.

Ο αλγόριθμος σίγουρα θα περάσει το μήκος της τράπουλας $n$. Στη χειρότερη περίπτωση όπου η τράπουλα θα είναι σε αύξουσα ακολουθία, τότε ο αλγόριθμος θα τρέξει ένα binary search για κάθε μήκος $k: 0 \leq k \leq n$. Οι εντολές απόθεσης και ανάκτησης μεταβλητών καθώς και τα boolean checks απαιτούν $\Theta(1)$ βήματα. Οπότε ο συνολικός χρόνος του αλγορίθμου θα είναι
$$T(n) = \log{1} + \log{2} + ... + \log{n} = \mathcal{O}(n\log{n})$$

2. Εφόσον με τον αλγόριθμο του (1) καταλήγουμε με μια λίστα από ταξινομημένες στοίβες, αρκεί να εκτελέσουμε \verb|stack[].length - 1| mergesort αλγορίθους και θα έχουμε ταξινομήσει την τράπουλα. Για να γίνει αποδοτικά θα πρέπει να κάνουμε merge τους πίνακες ανά δύο. Στη χειρότερη περίπτωση (όπου όπως και στο (1) θα έχουν δημιουργηθεί $n$ στοίβες) ο αλγόριθμος θα χρειαστεί
$$T(n) = 2\lfloor\frac{n}{2}\rfloor + 4\lfloor\frac{n}{4}\rfloor + ... = \mathcal{O}(n\log{n})$$
Εναλλακτικά, παρατηρούμε ότι στην περίπτωση που έχουν δημιουργηθεί $n$ στήλες τότε από το (ταξινομημένο) δέντρο με τις κορυφές των στοίβων έχουμε ήδη μια ταξινόμηση της τράπουλας. Θα μπορούσαμε λοιπόν να χρησιμοποιήσουμε έναν αλγόριθμο ο οποίος θα παίρνει ένα κλώνο του \verb|topCardTree| και να ταξινομεί σε χρόνο $T(\verb|topCardTree.length|)$ τα στοιχεία της στοίβας στο νέο δέντρο. Εδώ η χειρότερη περίπτωση είναι να έχουμε $n/2$ στοίβες όπου η καθεμία έχει 2 στοιχεία, οπότε και θα πρέπει να κάνουμε $n/2$ \verb|insert| στο δέντρο, και άρα ο χρόνος γίνεται πάλι
$$T(n) = \frac{n}{2}\log{(n/2)} = \mathcal{O}(n\log{n})$$

3. Με εισόδους $3, 2, 4, 7, 8, 1, 5, 6$ προκύπτει η διάταξη
$$\left[(3, 2, 1), (4), (7, 5), (8, 6)\right]$$
όπου προκύπτουν 4 στοίβες.

Επιπλέον, το μήκος της μέγιστης αύξουσας υπακολουθίας είναι επίσης $4$ (το οποίο εμφανίζεται σε μια υπακολουθία, την $[2, 4, 7, 8]$).

4. Για να δείξουμε ότι το πλήθος των στοιβών στις οποίες καταλήγουμε είναι πάντα μεγαλύτερο ή ίσο του μήκους της μέγιστης αύξουσας υπακολουθίας της εισόδου, αρκεί να δείξουμε ότι σε μια μέγιστη ακολουθία $α_1, α_2, ..., α_k$ ο κάθε όρος ανήκει σε διαφορετική στοίβα.

Με επαγωγή. Η επαγωγική υπόθεση είναι προφανής. Έστω τώρα ότι για $n \leq k$ ισχύει ότι κάθε όρος της ακολουθίας βρίσκεται σε διαφορετική στοίβα και τραβάμε τον $k+1$-όρο. Η κάθε στοίβα που ήδη περιέχει έναν (μικρότερο) όρο δεν θα είναι διαθέσιμη, άρα θα πρέπει να τοποθετήσουμε την κάρτα είτε σε άλλη στοίβα είτε σε καινούργια. Άρα και για $k+1$ στοιχεία η υπόθεση ισχύει.

5. Σε σχέση με το πρόβλημα της μέγιστης αύξουσας υπακολουθίας, το κορυφαίο στοιχείο της $k$-στής στοίβας είναι το στοιχείο για το οποίο θα πρέπει να υπολογίσουμε το \verb|max| όλων των υπακολουθιών του. Δεδομένου λοιπόν ότι ξέρουμε ότι τα προηγούμενα στοιχεία της ακολουθίας που είναι μικρότερά του βρίσκονται αποκλειστικά στις στοίβες στα δεξιά, και από τις κορυφές προς τα κάτω, μπορούμε να βρούμε γρήγορα τα στοιχεία αυτά και να υπολογίσουμε το \verb|max| των υπακολουθιών τους (είτε αναδρομικά είτε δυναμικά).

Σχετικά με το μήκος της μέγιστης φθίνουσας υπακολουθίας, παρατηρώ ότι η δομή που μας δίνει ο αλγόριθμος δεν μας δίνει κάποια πληροφορία για αυτό.

6. Έστω ότι ο αλγόριθμος του $(1)$ δεν δημιουργεί τουλάχιστον $n+1$ στοίβες, δηλαδή δημιουργεί το πολύ $n$. Θα δείξω ότι έχει μια στοίβα μεγέθους τουλάχιστον $m+1$. Έστω ότι δεν έχει. Οπότε κάθε στοίβα έχει το πολύ $m$ στοιχεία. Όμως τότε στις $n$ στοίβες θα χωράνε μόνο $nm$ στοιχεία. Άτοπο.

Αυτό συνδέεται με το θεώρημα του Περιστερώνα.

Η ακολουθία:
$$5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 15, 14, 13, 12, 11, 20, 19, 18, 17, 16, 25, 24, 23, 22, 21$$
δίνει την εξής λίστα από στοίβες:
$$\left[(5, 4, 3, 2, 1), (10, 9, 8, 7, 6), (15, 14, 13, 12, 11), (20, 19, 18, 17, 16), (25, 24, 23, 22, 21)\right]$$

\end{document}
